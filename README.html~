<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README.html</title>

</head>

<body>

<h1>Permutation</h1>

<h2>前置き</h2>

<p>この度は私が Twitter 上で軽々しく「○○できない？（後述）」と言って <br />
多くの人の貴重な時間を奪ったことを反省しております。 <br />
せめてもの罪滅ぼしで、皆様にいただいた知見をここに残しておきます。</p>

<h2>問題設定</h2>

<p>長さ n の配列 a と順列 p が与えられたとき、 <br />
a を p 順に並べ替えて得られる配列を p(a) とします。  </p>

<p>つまり、p(a) を得る関数を愚直に書くと以下のようになります。</p>

<pre><code>def permuate(a, p):
    return [ a[ p[i] ] for i in xrange( len(a) ) ]
</code></pre>

<p>この関数は O(n) の時間計算量で O(n) の新たな配列を生成しています。  </p>

<p>ここで以下の疑問が生じるわけです。</p>

<p>「a から p(a) への並べ替えは、外部メモリを使うことなく O(n) の時間計算量で可能か」</p>

<p>これを達成するする方法を教えてくれた人たちがいるので <br />
感謝の気持ちを込めてここに紹介します。</p>

<h2>方法1 : [beam2d][beam2d] 法</h2>

<pre><code>def permuate1(a, p):
    for i in xrange(len(a)):
        t, p[i] = p[i], a[i]           # escape p[i] -&gt;t and a[i] -&gt; p[i]
        a[i] = a[t] if t &gt; i else p[t] # change a[i] to (escaped) target value
</code></pre>

<p>この手法のポイントは a[i] を書き換えるときに <br />
その値を p[i] に待避することです。  </p>

<p>これで a[i] を a[ p[i] ] に書き換えようとしたときに <br />
既に a[ p[i] ] が変更されていても <br />
代わりに p[ p[i] ] から値をとれるという寸法です。  </p>

<p>この方法は a のみではなく、p も破壊します。 <br />
また a の要素は p に待避可能であると仮定します。 <br />
つまり sizeof(a[i]) > sizeof(p[i]) であるときには使えません。</p>

<h2>方法2 : [calicolicali][calicolicali] 法</h2>

<pre><code>def permutate2(a, p):
    n = len(a)

    # permutate a
    for i in xrange(n):
        # permuate cycle starting with i
        j = i
        while p[j] &lt; n:
            k = p[j]     # next point
            if k != i: a[j], a[k] = a[k], a[j] # swap if not starting point
            p[j] = k + n # mark as visited
            j = k        # move to next

    # recover p
    for i in xrange(n):
        p[i] -= n
</code></pre>

</body>
</html>
